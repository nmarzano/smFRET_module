import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import os
from scipy.optimize import curve_fit
from scipy.stats import ks_2samp
from itertools import combinations
from smfret.src.processing_scripts import synchronised_transition_processing as ps



def plot_synchronised_transition(dfs, index_to_plot, exposure_seconds, order, frame_from_trans, save_loc, palette, label=''):
    """plots the FRET values either side of a transition type of interest

    Args:
        dfs (df): dataframe containing the raw FRET values (generated after the calculate dwells function)
        index_to_plot (list): list of index values that met the criteria defined in 'filt_df_to_plot' that will the be mapped to df for plotting of raw FRET values
        exposure_seconds (float): exposure in seconds used to convert frames to a unit of time
        list_to_drop (list): list containing the name of all treatments to be dropped
        frame_from_trans (int, optional): should be the same as 'min_dwell_before' variable in the 'filt_df_to_plot' function, basically sets the xlims. Defaults to 80.
    """
    combined_mini=[]
    for df in index_to_plot:
        print(df)
        lower = df - frame_from_trans
        upper = df + (frame_from_trans+1)
        upper = min(upper, len(dfs))
            # Calculate the length of the range that will be generated by np.arange
        range_length = upper - lower
        # Calculate time values based on the index of interest and the exposure time
        time_from_trans = np.arange(-(frame_from_trans/(1/exposure_seconds)), 
                                    -(frame_from_trans/(1/exposure_seconds))+exposure_seconds*range_length, 
                                    exposure_seconds)[:range_length]
        mini_df = dfs.iloc[lower:upper].reset_index()
        mini_df['time_from_trans'] = time_from_trans
        combined_mini.append(mini_df)
    combined_mini = pd.concat(combined_mini)
    fig, axes = plt.subplots()
    sns.set(style='ticks')
    sns.lineplot(data=combined_mini, x='time_from_trans', y='FRET', hue='treatment_name', palette=palette, hue_order=order)
    plt.xlabel('Time (s)')
    plt.legend(title='',loc='best')
    plt.ylim(0, 0.8)
    fig.savefig(f'{save_loc}/synchronised_release{"_"+label}.svg', dpi=600)
    plt.show()

def plot_synchronised_transition2(dfs, index_to_plot, index_to_plot2, exposure_seconds, order, frame_from_trans, save_loc, palette, add_time=0, label = ''):
    combined_mini = []
    for df in index_to_plot:
        print(df)
        lower = df - frame_from_trans
        upper = df + (frame_from_trans+1) + (add_time/exposure_seconds)
        upper = int(min(upper, len(dfs)))
            # Calculate the length of the range that will be generated by np.arange
        range_length = int(upper - lower)
        # Calculate time values based on the index of interest and the exposure time
        time_from_trans = np.arange(-(frame_from_trans/(1/exposure_seconds)), 
                                    -(frame_from_trans/(1/exposure_seconds))+exposure_seconds*range_length, 
                                    exposure_seconds)[:range_length]
        mini_df = dfs.iloc[lower:upper].reset_index()
        mini_df['time_from_trans'] = time_from_trans
        combined_mini.append(mini_df)
    combined_mini = pd.concat(combined_mini)
    filt_data = combined_mini
    combined_mini2 = []
    for df in index_to_plot2:
        print(df)
        lower = df - frame_from_trans
        upper = df + (frame_from_trans+1) + (add_time/exposure_seconds)
        upper = int(min(upper, len(dfs)))
            # Calculate the length of the range that will be generated by np.arange
        range_length = int(upper - lower)
        # Calculate time values based on the index of interest and the exposure time
        time_from_trans = np.arange(-(frame_from_trans/(1/exposure_seconds)), 
                                    -(frame_from_trans/(1/exposure_seconds))+exposure_seconds*range_length, 
                                    exposure_seconds)[:range_length]
        mini_df2 = dfs.iloc[lower:upper].reset_index()
        mini_df2['time_from_trans'] = time_from_trans
        combined_mini2.append(mini_df2)
    combined_mini2 = pd.concat(combined_mini2)
    filt_data2 = combined_mini2

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6, 4), sharex=True, sharey=True)
    sns.set(style = 'ticks')
    sns.lineplot(data = filt_data, x = 'time_from_trans', y = 'FRET', hue = 'treatment_name', palette = palette, hue_order = order, ax=ax2)
    sns.lineplot(data = filt_data2, x = 'time_from_trans', y = 'FRET', hue = 'treatment_name', palette = palette, hue_order = order, ax=ax1)

    ax1.set_xlabel('Time (s)')
    ax2.set_xlabel('Time (s)')
    # plt.xlim(-(frame_from_trans/(1/exposure_seconds)),(frame_from_trans/(1/exposure_seconds)+add_time))
    # plt.legend(title = '',loc = 'best')
    ax1.legend('',loc='upper left')
    ax2.legend('')
    fig.savefig(f'{save_loc}/synchronised_release{"_"+label}.svg', dpi = 600)
    plt.show()
    return filt_data, filt_data2

# -------------------- Code to plot the percentage transition data -------------------------------

def plot_summary_transition(save_loc, order, df, palette, filt=True):
    """
    Plots a summary of transition data as bar plots, optionally filtering for a specific variable.
    Parameters
    ----------
    save_loc : str
        The directory path where the resulting plot will be saved.
    order : list
        The desired order of the 'treatment' categories for plotting.
    df : pandas.DataFrame
        The input DataFrame containing transition data with columns 'treatment', 'repeat', and transition variables.
    palette : dict or str
        The color palette to use for the plot. Can be a seaborn palette name or a dictionary mapping treatments to colors.
    filt : bool, optional
        If True, filters the data to plot only the '% DnaK release are consecutive' variable. If False, plots all variables. Default is True.
    Returns
    -------
    None
        The function saves the plot to the specified location and displays it, but does not return any value.
    Notes
    -----
    - The function uses seaborn and matplotlib for plotting.
    - The plot is saved as 'consecutive_transition_summary.svg' in the specified directory.
    - The function expects the DataFrame to be in wide format, with transition variables as columns.
    """
    melted_data = df.melt(id_vars=['treatment', 'repeat'])
    # Ensure the order of the 'treatment' column
    melted_data['treatment'] = pd.Categorical(melted_data['treatment'], categories=order, ordered=True)
    fig, ax = plt.subplots(figsize=(3, 6))
    sns.set_style('ticks',{'grid.linestyle':'--', 'font_scale': 1.5})
    if filt == False:
        sns.barplot(data=melted_data, y='value', x='variable', hue='treatment', palette=palette, hue_order=order, edgecolor='black', order=order)
    else:
        ax = sns.barplot(data=melted_data[melted_data['variable']=='% DnaK release are consecutive'], y='value', x='treatment', palette='BuPu', hue_order=order, edgecolor='black', fill=False, order=order, capsize=.2, errcolor='black')
        sns.scatterplot(data=melted_data[melted_data['variable']=='% DnaK release are consecutive'], y='value', x='treatment', hue='treatment', palette='BuPu', hue_order=order, edgecolor='black', ax=ax, s=200)

    plt.xlabel('')
    plt.xticks(rotation=45)
    plt.legend(title='')
    plt.ylabel('Proportion of transitions (%)')
    fig.savefig(f'{save_loc}/consecutive_transition_summary.svg', dpi=600)
    plt.show()

def plot_consec_DnaK_release_with_filter(dataframe, consecutive_trans, nonconsecutive_trans, FRET_before, FRET_after, palette, save_loc, datatype='Proportion'):
    helpplease = []
    for x, df in enumerate(range(0, 401)):
        if datatype == 'Proportion':
            dfs = ps.prop_DnaK_release_events_are_consecutive(dataframe, x, consecutive_trans, nonconsecutive_trans, FRET_before, FRET_after)
        else:
            dfs = ps.ratio_consecutive_to_nonconsecutive(dataframe, x, consecutive_trans, nonconsecutive_trans, FRET_before, FRET_after)
        dfs['frames_to_thresh'] = x
        helpplease.append(dfs)
        helpplease_df = pd.concat(helpplease).reset_index()
    sns.lineplot(data=helpplease_df, x='frames_to_thresh', y='prop_consecutive_dnaK_release', hue='treatment', palette=palette)
    plt.xlabel('Threshold prior to DnaK release (frames)')
    plt.ylabel(f'{datatype} of transitions (consecutive:non-consecutive)')
    plt.legend(title='')
    plt.savefig(f'{save_loc}/consecutive_transition_over_frame_threshold_{datatype}.svg', dpi=600)
    plt.show()
    return

def plot_FRET_after_release(plot_export, df, order, palette='BuPu'):
    fig, ax = plt.subplots()
    sns.violinplot(data=df, y='FRET_after', x='treatment_name', split=True, hue='consec', scale='width', palette=palette, inner='quart', order=order)
    plt.xlabel('')
    plt.legend(title='')
    plt.ylabel('FRET state after FRET increase')
    plt.xticks(rotation=45)
    plt.savefig(f'{plot_export}/FRET_state_after_increase.svg', dpi=600)
    plt.show()

# --------------------------------- Code to plot and fit the FRET after release -------------------------------------

def fit_ksdistribution(data, output_folder, palette='BuPu'):
    """
    Performs pairwise Kolmogorov-Smirnov (KS) tests on FRET data grouped by treatment, 
    visualizes the distributions with violin and cumulative distribution plots, 
    and saves the results and plots to the specified output folder.
    Parameters
    ----------
    data : pandas.DataFrame
        Input DataFrame containing at least the columns 'treatment_name' and 'FRET_after'.
        Each row should correspond to a measurement, with 'treatment_name' indicating the group.
    output_folder : str
        Path to the folder where output plots will be saved.
    palette : str or dict, optional
        Color palette for plotting. Can be a seaborn palette name or a dictionary mapping group names to colors.
        Default is 'BuPu'.
    Returns
    -------
    ks_results : pandas.DataFrame
        DataFrame containing the results of pairwise KS tests with columns:
        ["Group 1", "Group 2", "KS Statistic", "p-value"].
    Side Effects
    ------------
    - Saves violin and cumulative distribution plots as SVG and PNG files in the output folder.
    - Prints the number of non-NaN values per group and the sorted KS test results.
    Notes
    -----
    - Requires seaborn, matplotlib, pandas, and scipy.
    - Assumes 'FRET_after' is a numeric column.
    """
    dict_treatment = {
        treatment: group['FRET_after']
        for treatment, group in data.groupby('treatment_name')
    }
    df = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in dict_treatment.items()]))
    for key, values in dict_treatment.items():
        print(f"{key}: {len(values.dropna())} non-NaN values")
    # Pairwise KS Test
    results = []
    for (group1, group2) in combinations(df.columns, 2):
        stat, p_value = ks_2samp(df[group1].dropna(), df[group2].dropna())
        results.append([group1, group2, stat, p_value])
    # Convert results to a DataFrame
    ks_results = pd.DataFrame(results, columns=["Group 1", "Group 2", "KS Statistic", "p-value"])
    # Display results sorted by significance
    ks_results = ks_results.sort_values(by="p-value")
    print(ks_results)
    # Plot Violin Plots
    fig, ax = plt.subplots()
    sns.violinplot(data=df, inner="box", palette=palette)
    fig.savefig(f'{output_folder}/FRET_after_violin.svg', dpi=600)
    fig.savefig(f'{output_folder}/FRET_after_violin.png', dpi=600)
    plt.show()


    fig, ax = plt.subplots()
    # Loop through each group and plot its CDF
    for col in df.columns:
        if df[col].dropna().empty:
            print(f"Skipping {col} (empty dataset)")
            continue
        sns.ecdfplot(df[col].dropna(), 
                     label=col, 
                     color=palette[col] if col in palette else 'gray')

    plt.xlabel("FRET after DnaK release")
    plt.ylabel("Cumulative Probability")
    plt.legend()
    fig.savefig(f'{output_folder}/FRET_after_cumulative.svg', dpi=600)
    fig.savefig(f'{output_folder}/FRET_after_cumulative.png', dpi=600)
    plt.show()
    return ks_results

def exp_func(x, A, k, C):
    return A * np.exp(-k * x) + C

def extract_exp_kinetics(df, output_folder, exp_func, x='time_from_trans', y='FRET', xlim=(0.5, 10), palette='BuPu'):
    """
    Extracts and fits exponential kinetics to FRET data for different treatments, and plots the results.
    This function filters the input DataFrame based on a specified time window, plots the mean FRET signal
    over time for each treatment, fits an exponential function to each treatment's data, and overlays the
    fitted curves on the plot. The fit parameters for each treatment are returned in a dictionary.
    Parameters
    ----------
    df : pandas.DataFrame
        Input DataFrame containing at least the columns specified by `x`, `y`, and 'treatment_name'.
    output_folder : str
        Path to the folder where the output plots will be saved.
    exp_func : callable
        Exponential function to fit to the data. Should take x and parameters as arguments.
    x : str, optional
        Column name to use as the x-axis (default is 'time_from_trans').
    y : str, optional
        Column name to use as the y-axis (default is 'FRET').
    xlim : tuple of float, optional
        Tuple specifying the (min, max) range of x values to include in the analysis (default is (0.5, 10)).
    palette : str or sequence, optional
        Color palette to use for plotting (default is 'BuPu').
    Returns
    -------
    fit_results : dict
        Dictionary mapping treatment names to their fitted parameters (A, k, C).
        Example: {'treatment1': {'A': ..., 'k': ..., 'C': ...}, ...}
    Saves
    -----
    - Line plot with fitted exponential curves as SVG and PNG in `output_folder`.
    """
    filt_df = df[(df['time_from_trans'] >= xlim[0]) & (df['time_from_trans'] <= xlim[1])]
    # Store fit results
    fit_results = {}
    # Plot
    plt.figure(figsize=(8, 6))
    sns.lineplot(data=filt_df, 
                 x=x, 
                 y=y, 
                 hue="treatment_name", 
                 estimator="mean", 
                 ci=68, 
                 palette=palette)  # or ci=68 for 68% CI
    # Fit exponential to each treatment
    for treatment, group in filt_df.groupby("treatment_name"):
        x_data = group[x].values
        y_data = group[y].values
        # Initial guesses for A, k, C
        p0 = [max(y_data) - min(y_data), 0.3, min(y_data)]
        try:
            popt, _ = curve_fit(exp_func, x_data, y_data, p0=p0)
            A_fit, k_fit, C_fit = popt
            fit_results[treatment] = {"A": A_fit, "k": k_fit, "C": C_fit}
            # Plot fitted curve
            x_fit = np.linspace(xlim[0], xlim[1], 100)
            y_fit = exp_func(x_fit, *popt)
            plt.plot(x_fit, y_fit, linestyle="solid", color='black')
        except RuntimeError:
            print(f"Fit failed for {treatment}")
    plt.legend()
    plt.savefig(f'{output_folder}/DnaK_rebinding_fits.svg', dpi=600)
    plt.savefig(f'{output_folder}/DnaK_rebinding_fits.png', dpi=600)
    plt.show()
    return fit_results

def plot_fit_parameters(fit_results, output_folder, x='index', y='value', palette='BuPu', list_to_keep=None):
    """
    Plots bar charts of fit parameters from the provided fit results and saves the figure.
    Parameters
    ----------
    fit_results : dict
        Dictionary containing fit results, where keys are dataset identifiers and values are parameter dictionaries.
    output_folder : str
        Path to the folder where the output plot image will be saved.
    x : str, optional
        Column name to use for the x-axis in the bar plots (default is 'index').
    y : str, optional
        Column name to use for the y-axis in the bar plots (default is 'value').
    palette : str or list, optional
        Color palette to use for the bar plots (default is 'BuPu').
    list_to_keep : list, optional
        List of dataset identifiers to include in the plot. Defaults to all keys in `fit_results`.
    Returns
    -------
    None
        The function saves the generated plot as 'fit_parameters.png' in the specified output folder and displays it.
    """
    fits = pd.DataFrame(fit_results)
    fits = fits.transpose().reset_index().melt(id_vars='index')
    if list_to_keep is None:
        list_to_keep = list(fit_results.keys())
    dropped = fits[fits['index'].isin(list_to_keep)]
    dropped = dropped[~(dropped['variable'] == 'C')]

    fig, axes = plt.subplots(1, 2, sharey=True)
    for i, variable in enumerate(list(dropped['variable'].unique())):
        data = dropped[dropped['variable'] == variable]
        sns.barplot(data=data,
                    y=y,
                    x=x,
                    ax=axes[i],
                    palette=palette,
                    edgecolor='black')
        axes[i].set_xlabel(variable)
    plt.tight_layout()
    fig.savefig(f'{output_folder}/fit_parameters.png', dpi=600)
    fig.savefig(f'{output_folder}/fit_parameters.png', dpi=600)
    plt.show()

# -------------------------------- MASTER FUNCTION -----------------------------------------
    
def master_plot_synchronised_transitions(order, output_folder='Experiment_1-description/python_results', exposure=0.2, frames_to_plot=50, FRET_before=0.3,FRET_after=0.3, datatype='Proportion', filt=True, palette='BuPu', add_time=0):
    plot_export = f'{output_folder}/synchronised_transitions/'
    if not os.path.exists(plot_export):
        os.makedirs(plot_export)
    compiled_data = pd.read_csv(f'{output_folder}/Cleaned_FRET_histogram_data.csv')

    calculated_transitions = []
    for treatment, df in compiled_data.groupby('treatment_name'):
        dwell_df = ps.calculate_dwells(df)
        transition_df = ps.generate_transitions_sync(dwell_df)
        calculated_transitions.append(transition_df)
    calculated_transitions_df = pd.concat(calculated_transitions)
    calculated_transitions_df.reset_index(inplace=True)
    calculated_transitions_df.drop('index', axis=1, inplace=True)

    font = {'weight' : 'normal', 'size'   : 12 }
    plt.rcParams['font.sans-serif'] = "Arial"
    plt.rcParams['font.family'] = "sans-serif"
    plt.rc('font', **font)
    plt.rcParams['svg.fonttype'] = 'none'

    dnak_stable_release = ps.filt_df_to_plot(calculated_transitions_df, FRET_before, FRET_after,'low_to_high', frames_to_plot)
    plot_synchronised_transition(calculated_transitions_df, dnak_stable_release, exposure, order, frames_to_plot, plot_export, palette, label='release')

    dnak_stable_binding = ps.filt_df_to_plot(calculated_transitions_df, FRET_before, FRET_after, 'high_to_low', frames_to_plot)
    plot_synchronised_transition(calculated_transitions_df, dnak_stable_binding, exposure, order, frames_to_plot, plot_export, palette, label='binding')

    col = []
    for  treatment, df in calculated_transitions_df.groupby('treatment_name'):
        transition_data = df[df['transition_point']==True]
        transition_data['FRET_increase'] = transition_data['FRET_before'] < transition_data['FRET_after'] 
        consecutive_identified = ps.determine_first_transition_in_sequence(transition_data)
        col.append(consecutive_identified)
    consecutive_data = pd.concat(col)

    consecutive_trans, nonconsecutive_trans, percent_trans_meet_criteria_df = ps.concat_trans_proportion(
    consecutive_data, 
    calculated_transitions_df, 
    FRET_before, 
    FRET_after)


    consecutive_from_dnak_release = ps.filt_df_to_plot(consecutive_trans, FRET_before, FRET_after,'low_to_high', frames_to_plot)
    nonconsecutive_from_dnak_release = ps.filt_df_to_plot(nonconsecutive_trans, FRET_before, FRET_after,'low_to_high', frames_to_plot)

    plot_synchronised_transition(calculated_transitions_df, consecutive_from_dnak_release, exposure, order, frames_to_plot, plot_export, palette, label='consecutive_transitions')
    plot_synchronised_transition(calculated_transitions_df, nonconsecutive_from_dnak_release, exposure, order, frames_to_plot, plot_export, palette, label='non-consecutive_transition')


    plot_summary_transition(plot_export, order, percent_trans_meet_criteria_df, palette, filt=filt)

    plot_consec_DnaK_release_with_filter(calculated_transitions_df, consecutive_trans, nonconsecutive_trans, FRET_before, FRET_after, palette, save_loc=plot_export, datatype=datatype)


    first_consecutive_transition = calculated_transitions_df.iloc[consecutive_from_dnak_release]
    first_nonconsecutive_transition = calculated_transitions_df.iloc[nonconsecutive_from_dnak_release]
    first_consecutive_transition['consec'] = True
    first_nonconsecutive_transition['consec'] = False
    combined_consec_nonconsec = first_consecutive_transition.append(first_nonconsecutive_transition)
    combined_consec_nonconsec.to_csv(f'{plot_export}/combined_consecutive_nonconsecutive.csv', index=False)
    plot_FRET_after_release(plot_export, combined_consec_nonconsec, order)

    filt_data, filt_data2 = plot_synchronised_transition2(dfs=calculated_transitions_df, 
                                                          index_to_plot=consecutive_from_dnak_release, 
                                                          index_to_plot2=nonconsecutive_from_dnak_release,
                                                          exposure_seconds=exposure, 
                                                          order=order, 
                                                          frame_from_trans=frames_to_plot, 
                                                          save_loc=plot_export, 
                                                          palette=palette,  
                                                          label='consecutive_transitions', 
                                                          add_time=add_time)
    

    return percent_trans_meet_criteria_df, calculated_transitions_df, consecutive_from_dnak_release, nonconsecutive_from_dnak_release, filt_data, filt_data2, combined_consec_nonconsec

