import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import os
from scipy.optimize import curve_fit
from scipy.stats import ks_2samp
from itertools import combinations
from smfret.src.processing_scripts import synchronised_transition_processing as ps



def plot_synchronised_transition(dfs, index_to_plot, exposure_seconds, order, frame_from_trans, save_loc, palette, label='', ylim=(0, 0.8)):
    """plots the FRET values either side of a transition type of interest

    Args:
        dfs (df): dataframe containing the raw FRET values (generated after the calculate dwells function)
        index_to_plot (list): list of index values that met the criteria defined in 'filt_df_to_plot' that will the be mapped to df for plotting of raw FRET values
        exposure_seconds (float): exposure in seconds used to convert frames to a unit of time
        list_to_drop (list): list containing the name of all treatments to be dropped
        frame_from_trans (int, optional): should be the same as 'min_dwell_before' variable in the 'filt_df_to_plot' function, basically sets the xlims. Defaults to 80.
    """
    combined_mini=[]
    for df in index_to_plot:
        print(df)
        lower = df - frame_from_trans
        upper = df + (frame_from_trans+1)
        upper = min(upper, len(dfs))
            # Calculate the length of the range that will be generated by np.arange
        range_length = upper - lower
        # Calculate time values based on the index of interest and the exposure time
        time_from_trans = np.arange(-(frame_from_trans/(1/exposure_seconds)), 
                                    -(frame_from_trans/(1/exposure_seconds))+exposure_seconds*range_length, 
                                    exposure_seconds)[:range_length]
        mini_df = dfs.iloc[lower:upper].reset_index()
        mini_df['time_from_trans'] = time_from_trans
        combined_mini.append(mini_df)
    combined_mini = pd.concat(combined_mini)
    fig, axes = plt.subplots()
    sns.set(style='ticks')
    sns.lineplot(data=combined_mini, x='time_from_trans', y='FRET', hue='treatment_name', palette=palette, hue_order=order)
    plt.xlabel('Time (s)')
    plt.legend(title='',loc='best')
    plt.ylim(ylim)
    fig.savefig(f'{save_loc}/synchronised_release{"_"+label}.svg', dpi=600)
    plt.show()

def plot_synchronised_transition2(dfs, index_to_plot, index_to_plot2, exposure_seconds, order, frame_from_trans, save_loc, palette, add_time=0, label = '', ylim=(0, 0.8)):
    combined_mini = []
    for df in index_to_plot:
        print(df)
        lower = df - frame_from_trans
        upper = df + (frame_from_trans+1) + (add_time/exposure_seconds)
        upper = int(min(upper, len(dfs)))
            # Calculate the length of the range that will be generated by np.arange
        range_length = int(upper - lower)
        # Calculate time values based on the index of interest and the exposure time
        time_from_trans = np.arange(-(frame_from_trans/(1/exposure_seconds)), 
                                    -(frame_from_trans/(1/exposure_seconds))+exposure_seconds*range_length, 
                                    exposure_seconds)[:range_length]
        mini_df = dfs.iloc[lower:upper].reset_index()
        mini_df['time_from_trans'] = time_from_trans
        combined_mini.append(mini_df)
    combined_mini = pd.concat(combined_mini)
    filt_data = combined_mini
    combined_mini2 = []
    for df in index_to_plot2:
        print(df)
        lower = df - frame_from_trans
        upper = df + (frame_from_trans+1) + (add_time/exposure_seconds)
        upper = int(min(upper, len(dfs)))
            # Calculate the length of the range that will be generated by np.arange
        range_length = int(upper - lower)
        # Calculate time values based on the index of interest and the exposure time
        time_from_trans = np.arange(-(frame_from_trans/(1/exposure_seconds)), 
                                    -(frame_from_trans/(1/exposure_seconds))+exposure_seconds*range_length, 
                                    exposure_seconds)[:range_length]
        mini_df2 = dfs.iloc[lower:upper].reset_index()
        mini_df2['time_from_trans'] = time_from_trans
        combined_mini2.append(mini_df2)
    combined_mini2 = pd.concat(combined_mini2)
    filt_data2 = combined_mini2

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6, 4), sharex=True, sharey=True)
    sns.set(style = 'ticks')
    sns.lineplot(data = filt_data, x = 'time_from_trans', y = 'FRET', hue = 'treatment_name', palette = palette, hue_order = order, ax=ax2)
    sns.lineplot(data = filt_data2, x = 'time_from_trans', y = 'FRET', hue = 'treatment_name', palette = palette, hue_order = order, ax=ax1)

    ax1.set_xlabel('Time (s)')
    ax2.set_xlabel('Time (s)')
    # plt.xlim(-(frame_from_trans/(1/exposure_seconds)),(frame_from_trans/(1/exposure_seconds)+add_time))
    # plt.legend(title = '',loc = 'best')
    ax1.legend('',loc='upper left')
    ax2.legend('')
    plt.ylim(ylim)
    fig.savefig(f'{save_loc}/synchronised_release{"_"+label}.svg', dpi = 600)
    plt.show()
    return filt_data, filt_data2

# -------------------- Code to plot the percentage transition data -------------------------------

def plot_summary_transition(save_loc, order, df, palette, filt=True):
    """
    Plot a summary barplot of transition proportions and optionally overlay individual data points.
    This function expects a DataFrame containing at least the columns 'treatment' and 'repeat'
    plus one or more measurement columns (one commonly used column in this code is
    '% DnaK release are consecutive'). The DataFrame is first melted so that measurement
    columns become a single 'variable' column with associated 'value's. The 'treatment'
    column is converted to a categorical with the provided ordering so that plotting
    respects the requested order.
    Behavior
    - If filt is False:
        - Plots a grouped barplot of value (y) vs. variable (x) with bars colored by treatment.
    - If filt is True:
        - Filters the melted data to rows where variable == "% DnaK release are consecutive".
        - Plots a single bar per treatment showing the aggregate (Seaborn's default estimator).
        - Overlays individual data points jittered horizontally so they do not overlap.
        - Point colors follow the provided palette and points include black edgecolors.
    The function saves the resulting figure as an SVG to:
        {save_loc}/consecutive_transition_summary.svg
    and also displays the figure with plt.show().
    Parameters
    ----------
    save_loc : str or os.PathLike
        Directory path where the SVG file will be saved. Must be writable.
    order : sequence of str
        Ordered sequence of treatment names. This determines the categorical order for
        the 'treatment' column and the plotting order/legend order.
    df : pandas.DataFrame
        Input wide-format DataFrame containing:
          - 'treatment' (categorical or string-like): group/treatment labels
          - 'repeat' (identifier for repeated measurements)
          - one or more measurement columns (these become 'variable' after melt),
            e.g. '% DnaK release are consecutive'
    palette : dict or seaborn-compatible palette
        Color specification. Two accepted forms:
          - dict mapping treatment name -> color (hex or color name). If a treatment
            is missing from the dict, a default gray ("#333333") is used.
          - any value accepted by seaborn.color_palette (e.g., palette name string or list of colors).
    filt : bool, optional (default: True)
        If True, plot only the '% DnaK release are consecutive' variable and overlay
        jittered individual data points on the treatment bars. If False, plot all
        variables on the x-axis with treatment as the hue (grouped barplot).
    Returns
    -------
    None
        The function saves the figure to disk and shows it interactively; it does not
        return the figure or axes (though these are created internally).
    Notes
    -----
    - Dependencies: pandas (pd), seaborn (sns), matplotlib.pyplot (plt), numpy (np).
    - The function sets a fixed jitter_scale (0.08) for the horizontal jitter of points;
      adjust the code if a different spread is desired.
    - The plotted y-axis label is 'Proportion of transitions (%)' and the x-axis label is omitted.
    - The function assumes that the DataFrame will melt correctly with id_vars ['treatment', 'repeat'].
    - If using a custom palette dict, ensure the keys match values found in the 'treatment' column.
    Example
    -------
    # Assuming `df` contains the required columns and packages are imported:
    plot_summary_transition(save_loc='results/figs',
                            order=['control', 'treatmentA', 'treatmentB'],
                            df=df,
                            palette={'control': '#1f77b4', 'treatmentA': '#ff7f0e', 'treatmentB': '#2ca02c'},
                            filt=True)
    """
    melted_data = df.melt(id_vars=['treatment', 'repeat'])
    # Ensure the order of the 'treatment' column
    melted_data['treatment'] = pd.Categorical(melted_data['treatment'], categories=order, ordered=True)
    fig, ax = plt.subplots(figsize=(3, 6))
    sns.set_style('ticks', {'grid.linestyle':'--', 'font_scale': 1.5})

    # Normalize palette: allow either a dict mapping treatment -> color, or a seaborn palette name/list
    if isinstance(palette, dict):
        palette_for_hue = palette
        # create a list of colors in order for internal usage
        palette_colors = [palette.get(t, "#333333") for t in order]
        color_map = palette  # mapping treatment -> color
    else:
        palette_for_hue = sns.color_palette(palette, n_colors=len(order))
        palette_colors = palette_for_hue
        color_map = dict(zip(order, palette_colors))

    if filt == False:
        sns.barplot(data=melted_data, y='value', x='variable', hue='treatment',
                    palette=palette_for_hue, hue_order=order, edgecolor='black', order=order)
    else:
        # Use hue='treatment' so each treatment can be colored according to palette_for_hue
        ax = sns.barplot(data=melted_data[melted_data['variable']=='% DnaK release are consecutive'],
                         y='value', x='treatment', hue='treatment', palette=palette_for_hue,
                         edgecolor='black', order=order, capsize=.2, errcolor='black', dodge=False)

        # Jitter the datapoints so they don't overlap
        df_points = melted_data[melted_data['variable'] == '% DnaK release are consecutive'].copy()
        # map treatments to numeric x positions (0..n-1) using categorical codes
        x_codes = df_points['treatment'].cat.codes.values
        # small gaussian jitter; adjust scale for tighter/looser spread
        jitter_scale = 0.08
        jitter = np.random.normal(loc=0, scale=jitter_scale, size=len(x_codes))
        x_jittered = x_codes + jitter

        # get color for each treatment from the color_map
        colors = [color_map.get(t, "#333333") for t in df_points['treatment'].astype(str)]

        ax.scatter(x_jittered, df_points['value'].values, c=colors, edgecolors='black',
                   s=120, linewidths=0.8, zorder=10, alpha=0.9)

    plt.xlabel('')
    plt.xticks(rotation=45)
    plt.legend(title='')
    plt.ylabel('Proportion of transitions (%)')
    fig.savefig(f'{save_loc}/consecutive_transition_summary.svg', dpi=600)
    plt.show()

def plot_consec_DnaK_release_with_filter(dataframe, consecutive_trans, nonconsecutive_trans, FRET_before, FRET_after, palette, save_loc, datatype='Proportion'):
    helpplease = []
    for x, df in enumerate(range(0, 401)):
        if datatype == 'Proportion':
            dfs = ps.prop_DnaK_release_events_are_consecutive(dataframe, x, consecutive_trans, nonconsecutive_trans, FRET_before, FRET_after)
        else:
            dfs = ps.ratio_consecutive_to_nonconsecutive(dataframe, x, consecutive_trans, nonconsecutive_trans, FRET_before, FRET_after)
        dfs['frames_to_thresh'] = x
        helpplease.append(dfs)
        helpplease_df = pd.concat(helpplease).reset_index()
    sns.lineplot(data=helpplease_df, x='frames_to_thresh', y='prop_consecutive_dnaK_release', hue='treatment', palette=palette)
    plt.xlabel('Threshold prior to DnaK release (frames)')
    plt.ylabel(f'{datatype} of transitions (consecutive:non-consecutive)')
    plt.legend(title='')
    plt.savefig(f'{save_loc}/consecutive_transition_over_frame_threshold_{datatype}.svg', dpi=600)
    plt.show()
    return

def plot_FRET_after_release(plot_export, df, order, palette='BuPu'):
    fig, ax = plt.subplots()
    sns.violinplot(data=df, y='FRET_after', x='treatment_name', split=True, hue='consec', scale='width', palette=palette, inner='quart', order=order)
    plt.xlabel('')
    plt.legend(title='')
    plt.ylabel('FRET state after FRET increase')
    plt.xticks(rotation=45)
    plt.savefig(f'{plot_export}/FRET_state_after_increase.svg', dpi=600)
    plt.show()

# --------------------------------- Code to plot and fit the FRET after release -------------------------------------

def fit_ksdistribution(data, output_folder, palette='BuPu'):
    """
    Performs pairwise Kolmogorov-Smirnov (KS) tests on FRET data grouped by treatment, 
    visualizes the distributions with violin and cumulative distribution plots, 
    and saves the results and plots to the specified output folder.
    Parameters
    ----------
    data : pandas.DataFrame
        Input DataFrame containing at least the columns 'treatment_name' and 'FRET_after'.
        Each row should correspond to a measurement, with 'treatment_name' indicating the group.
    output_folder : str
        Path to the folder where output plots will be saved.
    palette : str or dict, optional
        Color palette for plotting. Can be a seaborn palette name or a dictionary mapping group names to colors.
        Default is 'BuPu'.
    Returns
    -------
    ks_results : pandas.DataFrame
        DataFrame containing the results of pairwise KS tests with columns:
        ["Group 1", "Group 2", "KS Statistic", "p-value"].
    Side Effects
    ------------
    - Saves violin and cumulative distribution plots as SVG and PNG files in the output folder.
    - Prints the number of non-NaN values per group and the sorted KS test results.
    Notes
    -----
    - Requires seaborn, matplotlib, pandas, and scipy.
    - Assumes 'FRET_after' is a numeric column.
    """
    dict_treatment = {
        treatment: group['FRET_after']
        for treatment, group in data.groupby('treatment_name')
    }
    df = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in dict_treatment.items()]))
    for key, values in dict_treatment.items():
        print(f"{key}: {len(values.dropna())} non-NaN values")
    # Pairwise KS Test
    results = []
    for (group1, group2) in combinations(df.columns, 2):
        stat, p_value = ks_2samp(df[group1].dropna(), df[group2].dropna())
        results.append([group1, group2, stat, p_value])
    # Convert results to a DataFrame
    ks_results = pd.DataFrame(results, columns=["Group 1", "Group 2", "KS Statistic", "p-value"])
    # Display results sorted by significance
    ks_results = ks_results.sort_values(by="p-value")
    print(ks_results)
    # Plot Violin Plots
    fig, ax = plt.subplots()
    sns.violinplot(data=df, inner="box", palette=palette)
    fig.savefig(f'{output_folder}/FRET_after_violin.svg', dpi=600)
    fig.savefig(f'{output_folder}/FRET_after_violin.png', dpi=600)
    plt.show()


    fig, ax = plt.subplots()
    # Loop through each group and plot its CDF
    for col in df.columns:
        if df[col].dropna().empty:
            print(f"Skipping {col} (empty dataset)")
            continue
        sns.ecdfplot(df[col].dropna(), 
                     label=col, 
                     color=palette[col] if col in palette else 'gray')

    plt.xlabel("FRET after DnaK release")
    plt.ylabel("Cumulative Probability")
    plt.legend()
    fig.savefig(f'{output_folder}/FRET_after_cumulative.svg', dpi=600)
    fig.savefig(f'{output_folder}/FRET_after_cumulative.png', dpi=600)
    plt.show()
    return ks_results

def exp_func(x, A, k, C):
    return A * np.exp(-k * x) + C

def extract_exp_kinetics(df, output_folder, exp_func, x='time_from_trans', y='FRET', xlim=(0.5, 10), palette='BuPu'):
    """
    Extracts and fits exponential kinetics to FRET data for different treatments, and plots the results.
    This function filters the input DataFrame based on a specified time window, plots the mean FRET signal
    over time for each treatment, fits an exponential function to each treatment's data, and overlays the
    fitted curves on the plot. The fit parameters for each treatment are returned in a dictionary.
    Parameters
    ----------
    df : pandas.DataFrame
        Input DataFrame containing at least the columns specified by `x`, `y`, and 'treatment_name'.
    output_folder : str
        Path to the folder where the output plots will be saved.
    exp_func : callable
        Exponential function to fit to the data. Should take x and parameters as arguments.
    x : str, optional
        Column name to use as the x-axis (default is 'time_from_trans').
    y : str, optional
        Column name to use as the y-axis (default is 'FRET').
    xlim : tuple of float, optional
        Tuple specifying the (min, max) range of x values to include in the analysis (default is (0.5, 10)).
    palette : str or sequence, optional
        Color palette to use for plotting (default is 'BuPu').
    Returns
    -------
    fit_results : dict
        Dictionary mapping treatment names to their fitted parameters (A, k, C).
        Example: {'treatment1': {'A': ..., 'k': ..., 'C': ...}, ...}
    Saves
    -----
    - Line plot with fitted exponential curves as SVG and PNG in `output_folder`.
    """
    filt_df = df[(df['time_from_trans'] >= xlim[0]) & (df['time_from_trans'] <= xlim[1])]
    # Store fit results
    fit_results = {}
    # Plot
    plt.figure(figsize=(8, 6))
    sns.lineplot(data=filt_df, 
                 x=x, 
                 y=y, 
                 hue="treatment_name", 
                 estimator="mean", 
                 ci=68, 
                 palette=palette)  # or ci=68 for 68% CI
    # Fit exponential to each treatment
    for treatment, group in filt_df.groupby("treatment_name"):
        x_data = group[x].values
        y_data = group[y].values
        # Initial guesses for A, k, C
        p0 = [max(y_data) - min(y_data), 0.3, min(y_data)]
        try:
            popt, _ = curve_fit(exp_func, x_data, y_data, p0=p0)
            A_fit, k_fit, C_fit = popt
            fit_results[treatment] = {"A": A_fit, "k": k_fit, "C": C_fit}
            # Plot fitted curve
            x_fit = np.linspace(xlim[0], xlim[1], 100)
            y_fit = exp_func(x_fit, *popt)
            plt.plot(x_fit, y_fit, linestyle="solid", color='black')
        except RuntimeError:
            print(f"Fit failed for {treatment}")
    plt.legend()
    plt.savefig(f'{output_folder}/DnaK_rebinding_fits.svg', dpi=600)
    plt.savefig(f'{output_folder}/DnaK_rebinding_fits.png', dpi=600)
    plt.show()
    return fit_results

def plot_fit_parameters(fit_results, output_folder, x='index', y='value', palette='BuPu', list_to_keep=None):
    """
    Plots bar charts of fit parameters from the provided fit results and saves the figure.
    Parameters
    ----------
    fit_results : dict
        Dictionary containing fit results, where keys are dataset identifiers and values are parameter dictionaries.
    output_folder : str
        Path to the folder where the output plot image will be saved.
    x : str, optional
        Column name to use for the x-axis in the bar plots (default is 'index').
    y : str, optional
        Column name to use for the y-axis in the bar plots (default is 'value').
    palette : str or list, optional
        Color palette to use for the bar plots (default is 'BuPu').
    list_to_keep : list, optional
        List of dataset identifiers to include in the plot. Defaults to all keys in `fit_results`.
    Returns
    -------
    None
        The function saves the generated plot as 'fit_parameters.png' in the specified output folder and displays it.
    """
    fits = pd.DataFrame(fit_results)
    fits = fits.transpose().reset_index().melt(id_vars='index')
    if list_to_keep is None:
        list_to_keep = list(fit_results.keys())
    dropped = fits[fits['index'].isin(list_to_keep)]
    dropped = dropped[~(dropped['variable'] == 'C')]

    fig, axes = plt.subplots(1, 2, sharey=True)
    for i, variable in enumerate(list(dropped['variable'].unique())):
        data = dropped[dropped['variable'] == variable]
        sns.barplot(data=data,
                    y=y,
                    x=x,
                    ax=axes[i],
                    palette=palette,
                    edgecolor='black')
        axes[i].set_xlabel(variable)
    plt.tight_layout()
    fig.savefig(f'{output_folder}/fit_parameters.png', dpi=600)
    fig.savefig(f'{output_folder}/fit_parameters.png', dpi=600)
    plt.show()

def TwoD_heatmap(df, output_folder, colors):
    os.makedirs(output_folder, exist_ok=True)
    for treatment, df_t in df.groupby('treatment_name'):
        if df_t.empty:
            continue
        plt.subplots(figsize=(6, 4))
        ax = plt.gca()
        col = colors.get(treatment, 'steelblue')
        # draw the vertical line with a low z-order so it sits below the KDE plots
        ax.axvline(0, color='darkorange', linestyle='--', zorder=1)
        sns.kdeplot(data=df_t, x='time_from_trans', y='FRET', bw_adjust=0.5, color=col, fill=True, zorder=2)
        sns.kdeplot(data=df_t, x='time_from_trans', y='FRET', bw_adjust=0.5, fill=False, color='black', zorder=3)
        plt.title(str(treatment))
        plt.tight_layout()
        plt.ylim(-0.2, 1.1)
        plt.xlabel('Time from transition (s)')
        plt.ylabel('FRET efficiency')
        plt.savefig(os.path.join(output_folder, f'kde_time_FRET_{treatment}.svg'), dpi=300)
        plt.show()
# -------------------------------- MASTER FUNCTION -----------------------------------------
    
def master_plot_synchronised_transitions(order, output_folder='Experiment_1-description/python_results', exposure=0.2, frames_to_plot=50, FRET_before=0.3,FRET_after=0.3, datatype='Proportion', filt=True, palette='BuPu', add_time=0, ylim=(0, 0.8)):
    plot_export = f'{output_folder}/synchronised_transitions/'
    if not os.path.exists(plot_export):
        os.makedirs(plot_export)
    compiled_data = pd.read_csv(f'{output_folder}/Cleaned_FRET_histogram_data.csv')

    calculated_transitions = []
    for treatment, df in compiled_data.groupby('treatment_name'):
        dwell_df = ps.calculate_dwells(df)
        transition_df = ps.generate_transitions_sync(dwell_df)
        calculated_transitions.append(transition_df)
    calculated_transitions_df = pd.concat(calculated_transitions)
    calculated_transitions_df.reset_index(inplace=True)
    calculated_transitions_df.drop('index', axis=1, inplace=True)

    font = {'weight' : 'normal', 'size'   : 12 }
    plt.rcParams['font.sans-serif'] = "Arial"
    plt.rcParams['font.family'] = "sans-serif"
    plt.rc('font', **font)
    plt.rcParams['svg.fonttype'] = 'none'

    dnak_stable_release = ps.filt_df_to_plot(calculated_transitions_df, FRET_before, FRET_after,'low_to_high', frames_to_plot)
    plot_synchronised_transition(calculated_transitions_df, dnak_stable_release, exposure, order, frames_to_plot, plot_export, palette, label='release')

    dnak_stable_binding = ps.filt_df_to_plot(calculated_transitions_df, FRET_before, FRET_after, 'high_to_low', frames_to_plot)
    plot_synchronised_transition(calculated_transitions_df, dnak_stable_binding, exposure, order, frames_to_plot, plot_export, palette, label='binding')

    col = []
    for  treatment, df in calculated_transitions_df.groupby('treatment_name'):
        transition_data = df[df['transition_point']==True]
        transition_data['FRET_increase'] = transition_data['FRET_before'] < transition_data['FRET_after'] 
        consecutive_identified = ps.determine_first_transition_in_sequence(transition_data)
        col.append(consecutive_identified)
    consecutive_data = pd.concat(col)

    consecutive_trans, nonconsecutive_trans, percent_trans_meet_criteria_df = ps.concat_trans_proportion(
    consecutive_data, 
    calculated_transitions_df, 
    FRET_before, 
    FRET_after)


    consecutive_from_dnak_release = ps.filt_df_to_plot(consecutive_trans, FRET_before, FRET_after,'low_to_high', frames_to_plot)
    nonconsecutive_from_dnak_release = ps.filt_df_to_plot(nonconsecutive_trans, FRET_before, FRET_after,'low_to_high', frames_to_plot)

    plot_synchronised_transition(calculated_transitions_df, consecutive_from_dnak_release, exposure, order, frames_to_plot, plot_export, palette, label='consecutive_transitions',ylim=ylim)
    plot_synchronised_transition(calculated_transitions_df, nonconsecutive_from_dnak_release, exposure, order, frames_to_plot, plot_export, palette, label='non-consecutive_transition',ylim=ylim)


    plot_summary_transition(plot_export, order, percent_trans_meet_criteria_df, palette, filt=filt)

    plot_consec_DnaK_release_with_filter(calculated_transitions_df, consecutive_trans, nonconsecutive_trans, FRET_before, FRET_after, palette, save_loc=plot_export, datatype=datatype)


    first_consecutive_transition = calculated_transitions_df.iloc[consecutive_from_dnak_release]
    first_nonconsecutive_transition = calculated_transitions_df.iloc[nonconsecutive_from_dnak_release]
    first_consecutive_transition['consec'] = True
    first_nonconsecutive_transition['consec'] = False
    combined_consec_nonconsec = first_consecutive_transition.append(first_nonconsecutive_transition)
    combined_consec_nonconsec.to_csv(f'{plot_export}/combined_consecutive_nonconsecutive.csv', index=False)
    plot_FRET_after_release(plot_export, combined_consec_nonconsec, order)

    filt_data, filt_data2 = plot_synchronised_transition2(dfs=calculated_transitions_df, 
                                                          index_to_plot=consecutive_from_dnak_release, 
                                                          index_to_plot2=nonconsecutive_from_dnak_release,
                                                          exposure_seconds=exposure, 
                                                          order=order, 
                                                          frame_from_trans=frames_to_plot, 
                                                          save_loc=plot_export, 
                                                          palette=palette,  
                                                          label='consecutive_transitions', 
                                                          add_time=add_time, 
                                                          ylim=ylim)
    

    return percent_trans_meet_criteria_df, calculated_transitions_df, consecutive_from_dnak_release, nonconsecutive_from_dnak_release, filt_data, filt_data2, combined_consec_nonconsec

